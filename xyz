import os
import openai
import pandas as pd

def load_data_dictionary(excel_path: str) -> pd.DataFrame:
    """
    Loads the data dictionary from an Excel file into a pandas DataFrame.
    """
    return pd.read_excel(excel_path)

def load_rules_txt(rules_txt_path: str) -> str:
    """
    Loads the entire domain rules from a text file.
    """
    with open(rules_txt_path, 'r', encoding='utf-8') as f:
        return f.read()

def load_abbreviations(abbreviations_csv_path: str) -> pd.DataFrame:
    """
    Loads abbreviations from a CSV file. 
    Expects columns: [word, abbreviation].
    """
    return pd.read_csv(abbreviations_csv_path)

def chunk_abbreviations(df_abbr: pd.DataFrame, chunk_size: int = 500):
    """
    Splits abbreviations into smaller chunks to avoid hitting token limits.
    """
    records = df_abbr.to_dict(orient='records')
    for i in range(0, len(records), chunk_size):
        yield records[i:i + chunk_size]

def generate_prompt_from_txt_rules(row_data: dict, rules_text: str, abbreviations_list: list) -> str:
    """
    Incorporates text-based domain rules, plus abbreviations, into the prompt.
    """
    abbreviations_text = "\n".join([
        f"{item['word']} -> {item['abbreviation']}" for item in abbreviations_list
    ])
    
    prompt = f"""
You are a data dictionary validation assistant. 
Apply the following domain rules strictly:
---
{rules_text}
---

Here is a list of relevant abbreviations for this batch:
{abbreviations_text}

Please review the following data dictionary row:

ACD: {row_data.get('ACD', '')}
Schema: {row_data.get('Schema', '')}
Table Name: {row_data.get('Table Name', '')}
Column Name: {row_data.get('Column Name', '')}
Data Type: {row_data.get('Data Type', '')}
Precision: {row_data.get('Precision', '')}
Scale: {row_data.get('Scale', '')}
Nullable?: {row_data.get('Nullable ?', '')}
Default Value: {row_data.get('Default value', '')}
Description/Business Rules: {row_data.get('Description/Business Rules', '')}
Is PK?: {row_data.get('Is PK (YES/NO)', '')}
Is FK?: {row_data.get('Is FK?(YES/NO)', '')}
Reference Table?: {row_data.get('Reference Table(YES/NO)', '')}

Task:
1) Identify any violations of the naming rules (e.g., length > 10, incorrect abbreviations, missing class words, etc.).
2) Suggest corrected naming if needed.
3) Indicate pass/fail and reason.

Return your response in JSON:
{{
    "compliance": "PASS" or "FAIL",
    "reasons": ["..."],
    "suggested_table_name": "...",
    "suggested_column_name": "...",
    "other_corrections": "...",
    "notes": "..."
}}
    """
    return prompt

def call_openai_api(prompt: str, model: str = "gpt-3.5-turbo") -> dict:
    try:
        response = openai.ChatCompletion.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            temperature=0.0,
            max_tokens=500
        )
        content = response['choices'][0]['message']['content']
        # Attempt JSON parsing
        import json
        try:
            result = json.loads(content)
        except json.JSONDecodeError:
            result = {"raw_response": content}
        return result
    except Exception as e:
        return {"error": str(e)}

def validate_row(row: pd.Series, rules_text: str, abbr_df: pd.DataFrame) -> dict:
    row_data = row.to_dict()
    for abbr_chunk in chunk_abbreviations(abbr_df, chunk_size=200):
        prompt = generate_prompt_from_txt_rules(row_data, rules_text, abbr_chunk)
        gpt_result = call_openai_api(prompt, model="gpt-4")  # or "gpt-3.5-turbo"
        
        if "compliance" in gpt_result:
            return gpt_result
    return {"compliance": "UNKNOWN", "notes": "No structured response received"}

def process_data_dictionary(df: pd.DataFrame, rules_text: str, abbr_df: pd.DataFrame) -> pd.DataFrame:
    results_list = []
    for idx, row in df.iterrows():
        validation_result = validate_row(row, rules_text, abbr_df)
        # Combine original row info + GPT output
        results_list.append({
            "RowID": idx,
            "Original_TableName": row.get("Table Name", ""),
            "Original_ColumnName": row.get("Column Name", ""),
            "Compliance": validation_result.get("compliance", "UNKNOWN"),
            "Reasons": validation_result.get("reasons", []),
            "Suggested_TableName": validation_result.get("suggested_table_name", ""),
            "Suggested_ColumnName": validation_result.get("suggested_column_name", ""),
            "Other_Corrections": validation_result.get("other_corrections", ""),
            "Notes": validation_result.get("notes", "")
        })
    return pd.DataFrame(results_list)

def main():
    openai.api_key = os.getenv("OPENAI_API_KEY", "YOUR_API_KEY")

    excel_path = "data/data_dictionary.xlsx"
    rules_txt_path = "data/domain_rules.txt"
    abbreviations_csv_path = "data/abbreviations.csv"

    # Load Data
    df_dict = load_data_dictionary(excel_path)
    rules_text = load_rules_txt(rules_txt_path)
    df_abbr = load_abbreviations(abbreviations_csv_path)

    # Validate
    result_df = process_data_dictionary(df_dict, rules_text, df_abbr)

    # Export to Excel
    result_df.to_excel("validation_report.xlsx", index=False)
    print("Validation complete. Results saved to 'validation_report.xlsx'")

if __name__ == "__main__":
    main()
