import streamlit as st
from PIL import Image
import openai
import json
import base64
import io
import sqlite3
import ast
import pandas as pd
import re
import seaborn as sns
import matplotlib.pyplot as plt
import sqlparse
from sqlalchemy import create_engine

# Streamlit UI Configuration
st.set_page_config(page_title="SQL Query Generator", layout="wide")

## Header - Nav --------------------------

def get_image_as_data_url(file_path):
    with open(file_path, "rb") as image_file:
        encoded_image = base64.b64encode(image_file.read()).decode()
    return f"data:image/png;base64,{encoded_image}"

def get_custom_html(data_url):
    with open("custom_styles.html", "r") as file:
        return file.read().replace("{data_url}", data_url)

data_url = get_image_as_data_url("header3.png")
custom_html = get_custom_html(data_url)
st.markdown(custom_html, unsafe_allow_html=True)
st.markdown(
    """
    <div class='navbar'>
        <p></p>
    </div>
    """,
    unsafe_allow_html=True,
)

### End Header - nav -----------------------

#-----------------------------------------------


import openai

def generate_description_with_openai(metadata):
    try:
        # Count the number of tables
        num_tables = len(metadata)
        
        # Create lists to store table names, column names, and column types
        table_names = []
        all_columns = []
        column_types = []
        
        # Iterate over the tables in the metadata
        for table_name, table_info in metadata.items():
            table_names.append(table_name)
            if 'columns' in table_info:
                for column in table_info['columns']:
                    all_columns.append(column['name'])
                    if 'type' in column:
                        column_types.append(column['type'])
        
        # Check if there are enough tables to generate a description
        if num_tables == 0:
            return "The metadata does not contain enough information about the tables to generate a description."

        # Create a prompt for the OpenAI API
        prompt = (
            f"""As a seasoned data analyst examining a database consisting of {num_tables} tables, namely {', '.join(table_names)}, 
            I have observed a variety of attributes across these tables. 
            The database encompasses a wide range of columns, including {', '.join(table_names)}. 
            Could you assist me in articulating a comprehensive and insightful summary, 
            shedding light on the potential contents, overarching themes, and the unique aspects of this database? 
            I am aiming for a narrative that offers a holistic and nuanced understanding of how this database could be leveraged for analytical purposes.
            Give a strictly 30 words description only.
            """
        )

        # Call the OpenAI API
        response = openai.Completion.create(
            model="text-davinci-003",
            prompt=prompt,
            max_tokens=150
        )
        
        # Extract the response text
        description = response['choices'][0]['text'].strip()
        return description
    
    except Exception as e:
        print(f"An error occurred: {str(e)}")
        return "An error occurred while generating the description."





#------------------------------------------------



# Initialize the OpenAI API
openai.api_key = ""


def format_metadata_for_prompt(metadata):
    if isinstance(metadata, list):
        tables = [item['name'] for item in metadata]
        columns = {table['name']: [col['name'] for col in table['columns']] for table in metadata}
    else:
        tables = list(metadata.keys())
        columns = {table: [col['name'] for col in metadata[table]['columns']] for table in tables}
    return {"tables": tables, "columns": columns}


# Add a function to connect to the database
def connect_to_db(host, port, user, password, dbname):
    # This is for SQLite; for other databases, modify the connection string
    conn_str = f"sqlite:///{dbname}"
    return sqlite3.connect(conn_str)


def get_table_download_link(df, filename="results.xlsx", text="Download results"):
    """Generates a link allowing the data in a given panda dataframe to be downloaded"""
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
        df.to_excel(writer, sheet_name='Sheet1')
    binary_data = output.getvalue()
    b64 = base64.b64encode(binary_data).decode()
    return f'<a href="data:application/octet-stream;base64,{b64}" download="{filename}">{text}</a>'



def is_select_statement(query):
    parsed = sqlparse.parse(query)
    if parsed:
        return parsed[0].get_type().lower() == 'select'
    return False

def generate_sql_query(prompt, formatted_metadata):
    # Set up the conversation with the model
    messages = [

{"role": "system", "content": f"""Based on the provided metadata, generate a SQL query in accordance with the following rules:

Metadata

Tables and columns:
Tables: {formatted_metadata['tables']}
Columns: {formatted_metadata['columns']}
User's Prompt: {prompt}

Step 1: Generate sql

Please adhere to these guidelines when generating SQL queries:

**Data Availability and Schema Constraints:**
1. Use only the tables and columns provided in the metadata for the SQL query. Introducing any table or column not explicitly mentioned in the metadata is not allowed.
2. Avoid making assumptions or expansions upon the database schema based on the user's prompt. Treat any data not present in the provided metadata as out of scope.
3. Ensure that every column referred to in the SQL query can be directly traced back to the provided metadata (Tables/Columns). Do not synthesize or assume any columns based on context.
4. Do not create, reference, or rely on temporary, derived, or virtual tables that aren't explicitly part of the provided metadata.

**Query Interpretation and Assumptions:**
5. If a user prompt is ambiguous and can be interpreted in multiple ways, refer back to the metadata to select the interpretation that aligns with the available tables and columns.
6. Do not make assumptions about the relationships between tables unless such relationships are clear and explicit in the metadata.
7. If the user's prompt conflicts with the provided metadata, prioritize adhering to the metadata's constraints. Provide a clear message or error about the discrepancy rather than filling gaps with assumptions.
8. Avoid generating subqueries that introduce tables or columns not present in the provided metadata.
9. Do not infer joins or relationships between tables that are not explicitly stated in the metadata.

**SQL Query Standards and Practices:**
10. Ensure that the generated SQL query adheres to general standards and is easily understandable.
11. Maintain consistent SQL syntax and formatting, with appropriate use of whitespace and indentation for readability.
12. Use aliases for tables and sub-queries to enhance readability and ensure clarity in referencing.
13. When using JOIN operations, ensure that the ON clause explicitly states the criteria for the join, and avoid using USING as it might not be clear which columns are being used for the join, especially if the tables have multiple columns with the same name.
14. Ensure that any GROUP BY statements are accompanied by the necessary aggregate functions or conditions to provide meaningful results.
15. Use comments in the SQL code to explain complex logic or decisions made during query generation.

**Query Optimization and Performance:**
16. Optimize the queries for performance, ensuring that joins and where clauses are using indexed columns wherever possible.
17. Avoid using nested queries unless absolutely necessary. If used, they should not be overly complex or deeply nested.
18. Utilize efficient filtering and sorting mechanisms, and avoid using functions on indexed columns in WHERE clauses as it can hinder performance.

**Data Selection and Aggregation:**
19. Ensure that the selected columns are relevant to the user's request and do not retrieve unnecessary data.
20. Encourage filtering data using 'WHERE' clauses to limit data retrieval to only what's necessary per the user's request.
21. Do not use aggregation functions like 'SUM', 'AVG', etc., unless the user's prompt explicitly asks for an aggregated result.
22. Use explicit 'JOIN' clauses instead of implicit ones to improve readability and ensure clarity in relationships between tables.

**Responsibility and Task Management:**
23. Ensure that the query has a single responsibility and does not try to accomplish multiple unrelated tasks.
24. Provide transparent messages or feedback indicating any mismatch or data limitations when a user's prompt requests data or relationships not covered in the metadata.

**Additional Guidelines:**
25. Ensure the query is accurate and does not have errors.
26. When selecting all the columns from a table, it's acceptable to use '*' for simplicity, unless specific column names are required for clarity.
27. Avoid using deprecated or obsolete SQL functions or syntax; ensure the generated SQL is up to date with current best practices.
28. Ensure that any date or time-based queries take into account different time zones or formats if applicable.
29. Provide clear and meaningful aliases for columns when renaming them using AS, to enhance the understandability of the results.
30. Ensure that the query results are presented in a clear and organized manner, with appropriate sorting or ordering applied.
31. Don't Concatenate columns, unless explicitly asked to do so.
32. Don't create a sql query where you ask the use to input any information. e.g :SELECT OrderID, ProductID, UnitPrice, Quantity, Discount
FROM Orders
WHERE OrderID = <order_id>;
33. Generate query according to Microsoft SQL Syntax. eg instaead of LIMIT use TOP

These guidelines aim to ensure that the generated SQL queries are of high quality, adhere to best practices, and provide accurate and efficient results based on the available metadata.


Step 1: review sql

**Guidelines for Reviewing the SQL Query:**

**1. Table and Column Validation:**
   - Ensure that the SQL query exclusively utilizes tables and columns that are listed in the provided metadata.
   - Confirm that no external or unlisted tables or columns are assumed or introduced in the query.

**2. SQL Standards and Optimization:**
   - Verify that the SQL query is optimized for performance, making use of indexed columns in JOIN operations and WHERE clauses.
   - Check that the query adheres to SQL standards, maintaining consistent syntax, and formatting.

**3. Accuracy and Precision:**
   - Make sure that the SQL query accurately represents the user’s request and retrieves the correct data.
   - Confirm that all JOIN conditions are explicitly stated and that there is clarity in the relationships between tables.

**4. Error and Ambiguity Handling:**
   - Ensure that the query does not contain any errors or ambiguous statements.
   - In cases of ambiguity in the user’s prompt, verify that the interpretation chosen aligns with the available tables and columns in the metadata.

**5. Data Selection and Aggregation:**
   - Confirm that the query selects only the necessary columns and does not retrieve excessive data.
   - Check that any aggregation functions used in the query are appropriate and explicitly requested in the user’s prompt.

**6. Clarity and Readability:**
   - Ensure that the query is easy to read and understand, using aliases for tables and sub-queries where necessary.
   - Verify that the formatting and indentation of the query enhance its readability.

**7. Feedback and Transparency:**
   - If the SQL query cannot be executed due to limitations in the provided metadata, provide clear and transparent feedback indicating the mismatch or data limitations.

**Providing an Improved Version:**
- If any issues are found based on the above guidelines, provide an improved version of the SQL query, ensuring alignment with the provided metadata and adherence to best practices.

The final output should have just the sql statement without any comments or additional description

"""}
    ]
    
    # Use OpenAI to generate SQL using the chat endpoint
    response = openai.ChatCompletion.create(
      model="gpt-3.5-turbo",
      messages=messages
    )
    
    # Extract the model's message from the response
    return response.choices[0].message['content'].strip()



def generate_query_description(generated_sql, formatted_metadata):
    # Formatting the metadata for better readability and understanding
    tables_str = ", ".join(formatted_metadata['tables'])
    columns_dict = formatted_metadata['columns']
    columns_str = ", ".join([f"{table}: {', '.join(columns)}" for table, columns in columns_dict.items()])
    
    # Set up the conversation with the model
    messages = [
        {"role": "system", "content": f"""
Please generate stricktly 30 words description for the following SQL query based on the provided metadata.

SQL Query:
{generated_sql}

Metadata:
Tables: {tables_str}
Columns: {columns_str}
"""}
    ]
    
    # Use OpenAI to generate the description
    response = openai.ChatCompletion.create(
      model="gpt-3.5-turbo",
      messages=messages
    )
    
    # Extract the model's message from the response
    description = response.choices[0]['message']['content'].strip()
    
    return description

#-----------------------------------------------------------------------
def query_result_data_with_openai(prompt, result_data):
    # Set up the conversation with the model
    messages = [
        {"role": "system", "content": """You are provided with the following data. Answer questions based on this. 
                                         If a visualization is requested, provide only pure Python code for plotting.
                                         only use the result data in the dataframe, don't create code for uploading csv

                                         Only use these packages: numpy, pandas, matplotlib, for visualization.
                                         Use 'df' as the dataframe variable. Example: df = result_data

                                        
                                         Provide the entire code for the plot, not in different parts.

                                         Otherwise, provide a textual answer."""},
        {"role": "user", "content": result_data.to_string()},
        {"role": "user", "content": prompt}
    ]

    # Use OpenAI to generate a response
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=messages
    )

    # Extract the model's message from the response
    full_response = response.choices[0].message['content'].strip()
    
    # Use regex to find code blocks enclosed in triple backticks
    code_blocks = re.findall(r"```python(.*?)```", full_response, re.DOTALL)
    
    if code_blocks:
        python_code = code_blocks[0].strip()
        # Format the Python code
        python_code = '\n'.join(line.strip() for line in python_code.split('\n') if line.strip())
        answer = re.sub(r"```python.*?```", "", full_response, flags=re.DOTALL).strip()
    else:
        answer = full_response
        python_code = None

    return answer, python_code

#---------------------------------------------------------------------------------
#   UI
#---------------------------------------------------------------------------------

# UI Components
image = Image.open('Capture.png')
st.image(image, width=200)
st.title("SQL and Report Generation using Open AI")

# Adjust the column widths
left_column, spacing_column1 , middle_column, spacing_column2 ,right_column = st.columns([0.16, 0.010, 0.20, 0.010, 0.20])
#middle_column ,right_column = st.columns([0.080, 0.20])

with left_column:
    uploaded_file = left_column.file_uploader("Upload DB Metadata JSON file", type="json")
    if uploaded_file:
        # Check if the file has changed since the last upload
        if 'uploaded_file_name' not in st.session_state or st.session_state.uploaded_file_name != uploaded_file.name:
            metadata = json.load(uploaded_file)
            st.session_state.formatted_metadata = format_metadata_for_prompt(metadata)
            
            # Call the API to get the data description
            data_summary = generate_description_with_openai(metadata)
            
            # Store the description and file name in the session state
            st.session_state.data_summary = data_summary
            st.session_state.uploaded_file_name = uploaded_file.name
        else:
            # If the file has not changed, use the stored description
            data_summary = st.session_state.data_summary
    else:
        # If no file is uploaded, clear the stored description and file name
        if 'data_summary' in st.session_state:
            del st.session_state.data_summary
        if 'uploaded_file_name' in st.session_state:
            del st.session_state.uploaded_file_name
        if 'formatted_metadata' in st.session_state:
            del st.session_state.formatted_metadata
        data_summary = None

    if data_summary:
        st.info(data_summary)


st.markdown("""
    <style>
        .stAlert > div {
            font-size: 4px !important;
        }
    </style>
""", unsafe_allow_html=True)

with middle_column:
    prompt = middle_column.text_area("Enter the question for the data you are looking for:")
    if 'sql_query' not in st.session_state:
        st.session_state.sql_query = ""
    if 'show_execute_button' not in st.session_state:
        st.session_state.show_execute_button = False
    if middle_column.button("Generate SQL"):
        if prompt and 'formatted_metadata' in st.session_state:
            with st.spinner("Generating response..."):
                st.session_state.sql_query = generate_sql_query(prompt, st.session_state.formatted_metadata)
                if 'data_summary' in st.session_state:
                    st.session_state.sql_description = generate_query_description(st.session_state.sql_query, st.session_state.formatted_metadata)



    # Add an image below
    #image_path = "Capture21342.png"  # Change this to the path of your image
    #st.image(image_path, use_column_width='always')

with right_column:
    # Display the generated SQL Query
    if st.session_state.sql_query:
        right_column.write('<p style="font-size: 0.9em; margin-bottom: 5px;">Generated SQL Query:</p>', unsafe_allow_html=True)
        right_column.code(st.session_state.sql_query, language="sql")

        if 'sql_description' in st.session_state and st.session_state.sql_description:
            #right_column.write('<p style="font-size: 0.9em; margin-top: 20px; margin-bottom: 5px;">SQL Query Description:</p>', unsafe_allow_html=True)
            right_column.info(st.session_state.sql_description)
        
        # Check if the query is a SELECT statement
        if is_select_statement(st.session_state.sql_query):
            # If it is, handle database connection and set the flag to not show the warning message
            # Existing database connection code goes here...
            db_host = "localhost"
            db_port = "50003"
            db_user = "test1"
            db_pass = "test1"
            db_name = "test1"
            try:
                conn_str = f"mssql+pyodbc://{db_user}:{db_pass}@{db_host}\\SQLEXPRESS:{db_port}/{db_name}?driver=ODBC+Driver+17+for+SQL+Server"
                engine = create_engine(conn_str)
                st.session_state.connection = engine.connect()
                st.session_state.show_execute_button = True
                st.session_state.show_non_select_warning = False
            except Exception as e:
                st.error(f"Error establishing connection: {str(e)}")
                st.session_state.show_execute_button = False
        else:
            # If it is not a SELECT statement, set the flag to show the warning message when "Execute Query" is pressed
            st.session_state.show_non_select_warning = True
    else:
        # If no SQL query is generated yet, display a placeholder
        right_column.write('<p style="font-size: 0.9em; margin-bottom: 5px;">Generated SQL Query:</p>', unsafe_allow_html=True)
        right_column.code("""e.g : SELECT * FROM Products ORDER BY Price DESC;""", language="sql")



    execute_button = right_column.button("Execute Query")
    
    if execute_button:
        # Check if the query is a SELECT statement
        if is_select_statement(st.session_state.sql_query):
            try:
                # If it is, execute the query
                df = pd.read_sql_query(st.session_state.sql_query, st.session_state.connection)
                df.index = df.index + 1
                st.session_state.query_executed = True
                st.session_state.query_result = df
                st.session_state.query_data_clicked = False
            except Exception as e:
                st.error("There was an error executing the query, try rephrasing your question to generate new SQL.")
                
                # Extract main error line
                match = re.search(r"\[SQL Server\](.*?)\(\d+\)", str(e))
                if match:
                    main_error_line = match.group(1).strip()
                    st.error(main_error_line)
                else:
                    st.error("An unexpected error occurred. Please check the query and try again.")
                
                st.session_state.query_executed = False
        else:
            # If it is not a SELECT statement, show a warning message
            st.warning("I can only execute SELECT statements")


# Results and Data Tables Tabs
with st.container():
    tab1, tab2 = st.tabs(["Results", "Metadata"])
    
    if 'query_executed' in st.session_state and st.session_state.query_executed:
        with tab1:
            col1, col2 = st.columns([1, 10])
            result_length = len(st.session_state.query_result)
            options = [10, 50, 100, 200, 500, 1000]
            options = [option for option in options if option <= result_length] + [result_length]
            with col1:
                num_rows = st.selectbox('Select rows:', options=options, index=0, format_func=lambda x: f"All {x}" if x == result_length else str(x))

            st.write('<p style="font-size: 1em; margin-bottom: 0px;"><b>Query Results:</b></p>', unsafe_allow_html=True)

            # Define the CSS styles
            style = """
            <style>
                .dataframe-container {
                    width: 100%;  /* Set width to 100% */
                    background-color: #4e7496;  /* Background color */
                    color: white;  /* Text color */
                    border-collapse: collapse;
                    margin-bottom: 1em;
                }
                .dataframe-container th, .dataframe-container td {
                    border: 1px solid black;
                    padding: 8px;
                    text-align: left;
                }
                .dataframe-container th {
                    background-color: #253547;  /* Header background color */
                }
                .scrollable-container {
                    overflow-x: auto;  /* Make horizontally scrollable */
                    overflow-y: auto;  /* Make vertically scrollable */
                    max-height: 500px;  /* Adjust as needed */
                }
            </style>
            """

            with st.container():
                # Convert dataframe to HTML and then use st.markdown to display it
                df_html = st.session_state.query_result.head(num_rows).to_html(classes='dataframe-container', escape=False)
                # Display the dataframe with styles
                st.markdown(style, unsafe_allow_html=True)
                st.markdown("<div class='scrollable-container'>" + df_html + "</div>", unsafe_allow_html=True)

            st.markdown(get_table_download_link(st.session_state.query_result), unsafe_allow_html=True)
            st.subheader("Analyze Result Data")


            with tab2:
                        if 'formatted_metadata' in st.session_state:
                            st.subheader("Database Tables and Columns:")
                            details = []
                            for table, columns in st.session_state.formatted_metadata['columns'].items():
                                line = f"<div style='margin-top: 0; padding: 0;'><strong style='color: #007ACC;'>{table}</strong>: <span style='color: #FFFFFF;'>{', '.join(columns)}</span></div>"
                                details.append(line)
                            st.markdown(f"""
                            <div style='white-space: pre-wrap; overflow-wrap: break-word; font-family: "Courier New", monospace; background-color: #253547; padding: 10px; border-radius: 5px; margin: 0; padding: 0;'>
                            <div style='margin-top: 0; padding-left: 1em;'>{''.join(details)}</div>
                            </div>
                            """, unsafe_allow_html=True)
                        else:
                            st.warning("Please upload the database metadata JSON file to view the database tables and columns.")


    # Initialize session state
    if 'query_data_clicked' not in st.session_state:
        st.session_state.query_data_clicked = False

    # User input for query
    result_query_prompt = st.text_area("Enter your question for additional analysis:")

    # Button to trigger query
    if st.button("Generate Results"):
        st.session_state.query_data_clicked = not st.session_state.query_data_clicked

    # Handle query and display results
    if st.session_state.query_data_clicked and result_query_prompt:
        with st.spinner("Querying data..."):
            answer, python_code = query_result_data_with_openai(result_query_prompt, st.session_state.query_result)
            
            # Display the textual answer
            if answer:
                st.write(answer)
                
            if python_code:
                # Set figure size
                fig_width, fig_height = 6, 4
                
                # Prepare the Python code for execution
                python_code = f'df = st.session_state.query_result\nimport matplotlib.pyplot as plt\nplt.figure(figsize=({fig_width}, {fig_height}))\n{python_code}\nst.pyplot(plt)'
                
            try:
                # Execute the Python code
                # Create a layout with three columns
                col1, col2, col3 = st.columns([1, 1, 1])
                with col2:
                    exec(python_code, globals())
                    #st.pyplot(plt)
            except Exception as e:
                st.error(f"Error executing the code: {str(e)}")
